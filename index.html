<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Mini Shooting (Mobile + Sound)</title>
  <style>
    html, body {
      margin: 0; height: 100%;
      background:#0b0f1a; color:#e8eefc;
      font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
      overflow: hidden;
    }
    #wrap { display:flex; align-items:center; justify-content:center; height:100%; padding: 14px; box-sizing: border-box; }
    canvas {
      width: min(92vw, 420px);
      height: auto;
      aspect-ratio: 420 / 720;
      background: radial-gradient(1200px 800px at 50% 60%, #101a35 0%, #070a12 55%, #05060b 100%);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,.45);
      touch-action: none;
    }
    .hud {
      position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
      display:flex; gap:10px; align-items:center; font-weight: 800; letter-spacing:.3px;
      background: rgba(0,0,0,.25); padding: 8px 12px; border-radius: 999px; border:1px solid rgba(255,255,255,.12);
      user-select:none;
      z-index: 10;
      backdrop-filter: blur(6px);
      flex-wrap: wrap;
      justify-content: center;
    }
    .hint {
      position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%);
      font-size: 12px; opacity: .88; background: rgba(0,0,0,.25);
      padding: 8px 12px; border-radius: 999px; border:1px solid rgba(255,255,255,.12);
      user-select:none;
      z-index: 10;
      backdrop-filter: blur(6px);
      text-align: center;
      max-width: 92vw;
    }
    button {
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.10);
      color:#e8eefc; border-radius: 10px; padding: 6px 10px; cursor:pointer; font-weight: 900;
    }
    button:hover { background: rgba(255,255,255,.16); }
    .small { font-size: 12px; font-weight: 800; opacity: .95; }
  </style>
</head>
<body>
  <div class="hud">
    <div>Score: <span id="score">0</span></div>
    <div>Life: <span id="life">3</span></div>
    <button id="restart" title="R„Åß„ÇÇOK">Restart</button>
    <button id="sound">üîá Sound OFF</button>
    <span class="small" id="soundHint">ÔºàÈü≥„ÅØ„Éú„Çø„É≥Êäº„Åó„Å¶ÊúâÂäπÂåñÔºâ</span>
  </div>
  <div class="hint">
    „Çπ„Éû„Éõ: ÁîªÈù¢„Éâ„É©„ÉÉ„Ç∞„ÅßÁßªÂãïÔºàÊäº„Åó„Å¶„ÇãÈñì„ÅØÈÄ£Â∞ÑÔºâ / PC: Áü¢Âç∞ÁßªÂãï + Space<br/>
    ‚ÄªiPhone„ÅØÈü≥„ÇíÈ≥¥„Çâ„Åô„ÅÆ„Å´ÊúÄÂàù„ÅÆ„Çø„ÉÉ„Éó„ÅåÂøÖË¶Å
  </div>

  <div id="wrap">
    <canvas id="c" width="420" height="720"></canvas>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const scoreEl = document.getElementById("score");
  const lifeEl  = document.getElementById("life");
  const restartBtn = document.getElementById("restart");
  const soundBtn = document.getElementById("sound");
  const soundHint = document.getElementById("soundHint");

  const W = canvas.width, H = canvas.height;

  // ====== Utils ======
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand  = (a, b) => a + Math.random() * (b - a);
  const now   = () => performance.now();

  // ====== Sound (Web Audio, no external files) ======
  let audioCtx = null;
  let master = null;
  let bgmGain = null;
  let sfxGain = null;
  let soundEnabled = false;
  let bgmTimer = null;
  let bgmStep = 0;

  function ensureAudio() {
    if (audioCtx) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AC();
    master = audioCtx.createGain();
    bgmGain = audioCtx.createGain();
    sfxGain = audioCtx.createGain();

    // volumes
    master.gain.value = 0.8;
    bgmGain.gain.value = 0.20;
    sfxGain.gain.value = 0.45;

    bgmGain.connect(master);
    sfxGain.connect(master);
    master.connect(audioCtx.destination);
  }

  function setSound(on) {
    ensureAudio();
    soundEnabled = on;
    if (audioCtx.state === "suspended") audioCtx.resume();

    soundBtn.textContent = on ? "üîä Sound ON" : "üîá Sound OFF";
    soundHint.textContent = on ? "" : "ÔºàÈü≥„ÅØ„Éú„Çø„É≥Êäº„Åó„Å¶ÊúâÂäπÂåñÔºâ";

    if (on) startBgm();
    else stopBgm();
  }

  function blip({freq=440, dur=0.07, type="sine", gain=0.25, toGain=sfxGain, slide=0, noise=false}) {
    if (!soundEnabled) return;
    ensureAudio();
    const t0 = audioCtx.currentTime;
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(gain, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

    if (noise) {
      // tiny noise burst
      const bufferSize = Math.floor(audioCtx.sampleRate * dur);
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) data[i] = (Math.random()*2-1) * Math.pow(1 - i/bufferSize, 2);
      const src = audioCtx.createBufferSource();
      src.buffer = buffer;

      // filter for "ÁàÜÁô∫„Å£„ÅΩ„Åï"
      const filter = audioCtx.createBiquadFilter();
      filter.type = "lowpass";
      filter.frequency.setValueAtTime(1200, t0);
      filter.frequency.exponentialRampToValueAtTime(180, t0 + dur);

      src.connect(filter);
      filter.connect(g);
      g.connect(toGain);

      src.start(t0);
      src.stop(t0 + dur);
      return;
    }

    const osc = audioCtx.createOscillator();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, t0);
    if (slide !== 0) osc.frequency.exponentialRampToValueAtTime(Math.max(40, freq + slide), t0 + dur);

    osc.connect(g);
    g.connect(toGain);
    osc.start(t0);
    osc.stop(t0 + dur);
  }

  // SFX
  const sfx = {
    shoot() { blip({freq: 760, dur: 0.05, type:"square", gain:0.12, slide:-220}); },
    hit()   { blip({freq: 220, dur: 0.08, type:"sawtooth", gain:0.18, slide:-120}); },
    boom()  { blip({dur: 0.18, gain:0.28, noise:true}); },
    damage(){ blip({freq: 140, dur: 0.16, type:"triangle", gain:0.22, slide:-60}); }
  };

  // BGM: simple step sequencer (sine-ish chiptune)
  function startBgm() {
    if (!soundEnabled) return;
    ensureAudio();
    if (bgmTimer) return;

    const scale = [0, 3, 5, 7, 10]; // minor pentatonic-ish
    const base = 220; // A3
    const pattern = [
      0, 2, 3, 2,  1, 2, 4, 2,
      0, 2, 3, 4,  3, 2, 1, 2
    ];

    bgmStep = 0;
    bgmTimer = setInterval(() => {
      if (!soundEnabled) return;
      const idx = pattern[bgmStep % pattern.length];
      const semis = scale[idx % scale.length] + (idx >= scale.length ? 12 : 0);
      const freq = base * Math.pow(2, semis/12);

      // note
      blip({freq, dur:0.12, type:"sine", gain:0.10, toGain:bgmGain});
      // soft "kick"
      if (bgmStep % 4 === 0) blip({freq: 90, dur:0.10, type:"sine", gain:0.08, toGain:bgmGain, slide:-20});

      bgmStep++;
    }, 140); // tempo
  }

  function stopBgm() {
    if (bgmTimer) { clearInterval(bgmTimer); bgmTimer = null; }
  }

  soundBtn.addEventListener("click", () => setSound(!soundEnabled));

  // ====== Game State ======
  let keys = new Set();
  let lastT = now();
  let running = true;

  const player = { x: W/2, y: H-90, r: 14, speed: 320, shootCd: 0, inv: 0 };

  let bullets = [];
  let enemies = [];
  let particles = [];
  let stars = [];

  let score = 0;
  let life = 3;
  let wave = 1;
  let spawnTimer = 0;

  // ====== Touch Controls ======
  let touchActive = false;
  let touchX = player.x;
  let touchY = player.y;

  function canvasPosFromTouch(ev) {
    const rect = canvas.getBoundingClientRect();
    const t = ev.touches ? ev.touches[0] : ev;
    const sx = W / rect.width;
    const sy = H / rect.height;
    const x = (t.clientX - rect.left) * sx;
    const y = (t.clientY - rect.top) * sy;
    return { x, y };
  }

  function onTouchStart(ev) {
    ev.preventDefault();
    touchActive = true;
    const p = canvasPosFromTouch(ev);
    touchX = p.x; touchY = p.y;

    // iOSÂØæÁ≠ñ: „Åì„Åì„ÅßÈü≥„ÇíÊúâÂäπÂåñ„Åó„Å¶„Åä„Åè„Å®Ê∞óÊåÅ„Å°„Çà„ÅèÈ≥¥„ÇäÂßã„ÇÅ„Çã
    if (soundEnabled) { ensureAudio(); if (audioCtx.state === "suspended") audioCtx.resume(); }
  }
  function onTouchMove(ev) {
    ev.preventDefault();
    const p = canvasPosFromTouch(ev);
    touchX = p.x; touchY = p.y;
  }
  function onTouchEnd(ev) {
    ev.preventDefault();
    touchActive = false;
  }

  canvas.addEventListener("touchstart", onTouchStart, { passive: false });
  canvas.addEventListener("touchmove",  onTouchMove,  { passive: false });
  canvas.addEventListener("touchend",   onTouchEnd,   { passive: false });
  canvas.addEventListener("touchcancel",onTouchEnd,   { passive: false });
  canvas.addEventListener("gesturestart", (e) => e.preventDefault());

  // ====== Background ======
  function initStars() {
    stars = Array.from({ length: 90 }, () => ({
      x: Math.random() * W,
      y: Math.random() * H,
      s: rand(0.6, 2.2),
      v: rand(18, 80)
    }));
  }

  // ====== Reset ======
  function reset() {
    bullets = [];
    enemies = [];
    particles = [];
    score = 0;
    life = 3;
    wave = 1;
    spawnTimer = 0;
    player.x = W / 2;
    player.y = H - 90;
    player.shootCd = 0;
    player.inv = 0;
    running = true;
    touchActive = false;
    scoreEl.textContent = score;
    lifeEl.textContent  = life;
    initStars();
  }

  restartBtn.addEventListener("click", reset);

  // ====== Particles ======
  function addParticleBurst(x, y, n=14) {
    for (let i=0;i<n;i++) {
      particles.push({
        x, y,
        vx: rand(-180, 180),
        vy: rand(-220, 120),
        r: rand(1.2, 3.2),
        a: 1,
        life: rand(0.25, 0.65)
      });
    }
  }

  // ====== Enemies ======
  function spawnEnemy() {
    const typeRoll = Math.random();
    const e = {
      x: rand(20, W - 20),
      y: -30,
      r: 16,
      hp: 1,
      vx: rand(-40, 40),
      vy: rand(80, 150) + wave * 6,
      spin: rand(-2, 2),
      ang: rand(0, Math.PI*2),
      kind: typeRoll < 0.15 ? "bossy" : "normal"
    };
    if (e.kind === "bossy") { e.r = 22; e.hp = 3; e.vy = rand(60, 110) + wave * 5; }
    enemies.push(e);
  }

  // ====== Input (Keyboard) ======
  window.addEventListener("keydown", (e) => {
    if (["ArrowLeft","ArrowRight","ArrowUp","ArrowDown","Space","KeyR"].includes(e.code)) e.preventDefault();
    keys.add(e.code);
    if (e.code === "KeyR") reset();
    // ‰Ωï„Åã„Ç≠„ÉºÊäº„Åó„Åü„ÇâÈü≥„ÅÆÊ∫ñÂÇô„Å†„Åë„Åó„Å¶„Åä„ÅèÔºàON„Å™„ÇâÔºâ
    if (soundEnabled) { ensureAudio(); if (audioCtx.state === "suspended") audioCtx.resume(); }
  }, { passive:false });

  window.addEventListener("keyup", (e) => keys.delete(e.code));

  // ====== Collision ======
  function hitCircle(ax, ay, ar, bx, by, br) {
    const dx = ax - bx, dy = ay - by;
    return (dx*dx + dy*dy) <= (ar+br)*(ar+br);
  }

  // ====== Draw helpers ======
  function drawShip(x, y, r, inv) {
    ctx.save();
    ctx.translate(x, y);

    ctx.globalAlpha = inv ? 0.55 : 1;
    ctx.shadowBlur = 18;
    ctx.shadowColor = "rgba(170,220,255,.6)";

    ctx.beginPath();
    ctx.moveTo(0, -r-10);
    ctx.lineTo(r+10, r+10);
    ctx.lineTo(0, r+2);
    ctx.lineTo(-r-10, r+10);
    ctx.closePath();
    ctx.fillStyle = "rgba(160,210,255,.92)";
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.beginPath();
    ctx.ellipse(0, -5, 7, 10, 0, 0, Math.PI*2);
    ctx.fillStyle = "rgba(80,140,255,.8)";
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(-8, r+10);
    ctx.lineTo(0, r+22 + Math.sin(now()/80)*2);
    ctx.lineTo(8, r+10);
    ctx.closePath();
    ctx.fillStyle = "rgba(255,180,80,.85)";
    ctx.fill();

    ctx.restore();
  }

  function drawEnemy(e) {
    ctx.save();
    ctx.translate(e.x, e.y);
    ctx.rotate(e.ang);

    ctx.shadowBlur = 16;
    ctx.shadowColor = e.kind === "bossy" ? "rgba(255,120,140,.55)" : "rgba(255,90,110,.35)";

    ctx.beginPath();
    ctx.moveTo(0, -e.r-6);
    ctx.lineTo(e.r+8, 0);
    ctx.lineTo(0, e.r+8);
    ctx.lineTo(-e.r-8, 0);
    ctx.closePath();

    ctx.fillStyle = e.kind === "bossy" ? "rgba(255,130,160,.95)" : "rgba(255,90,120,.9)";
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.beginPath();
    ctx.arc(0, 0, e.kind === "bossy" ? 8 : 6, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,240,240,.9)";
    ctx.fill();

    if (e.kind === "bossy") {
      ctx.beginPath();
      ctx.arc(0, 0, e.r+6, 0, Math.PI*2);
      ctx.strokeStyle = "rgba(255,255,255,.15)";
      ctx.lineWidth = 2;
      ctx.stroke();

      const p = e.hp / 3;
      ctx.beginPath();
      ctx.arc(0, 0, e.r+6, -Math.PI/2, -Math.PI/2 + Math.PI*2*p);
      ctx.strokeStyle = "rgba(255,255,255,.55)";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    ctx.restore();
  }

  function drawBullet(b) {
    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.shadowBlur = 14;
    ctx.shadowColor = "rgba(120,255,210,.6)";
    ctx.beginPath();
    ctx.roundRect(-2.5, -10, 5, 20, 3);
    ctx.fillStyle = "rgba(140,255,220,.95)";
    ctx.fill();
    ctx.restore();
  }

  // ====== roundRect polyfill ======
  if (!ctx.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r) {
      const rr = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+rr, y);
      this.arcTo(x+w, y, x+w, y+h, rr);
      this.arcTo(x+w, y+h, x, y+h, rr);
      this.arcTo(x, y+h, x, y, rr);
      this.arcTo(x, y, x+w, y, rr);
      this.closePath();
      return this;
    };
  }

  // ====== Update ======
  function update(dt) {
    // stars
    for (const s of stars) {
      s.y += s.v * dt;
      if (s.y > H + 10) { s.y = -10; s.x = Math.random() * W; s.v = rand(18, 80); s.s = rand(0.6, 2.2); }
    }

    if (!running) return;

    const shootDelay = 0.11;
    const spawnRate = Math.max(0.18, 0.60 - wave * 0.02);

    // keyboard move
    let dx = 0, dy = 0;
    if (keys.has("ArrowLeft")) dx -= 1;
    if (keys.has("ArrowRight")) dx += 1;
    if (keys.has("ArrowUp")) dy -= 1;
    if (keys.has("ArrowDown")) dy += 1;

    const len = Math.hypot(dx, dy) || 1;
    dx /= len; dy /= len;

    if (dx || dy) {
      player.x = clamp(player.x + dx * player.speed * dt, 18, W - 18);
      player.y = clamp(player.y + dy * player.speed * dt, 30, H - 30);
    }

    // touch follow
    if (touchActive) {
      const follow = 10;
      player.x += (touchX - player.x) * (1 - Math.exp(-follow * dt));
      player.y += (touchY - player.y) * (1 - Math.exp(-follow * dt));
      player.x = clamp(player.x, 18, W - 18);
      player.y = clamp(player.y, 30, H - 30);
    }

    // shooting
    const wantShoot = keys.has("Space") || touchActive;
    player.shootCd -= dt;
    if (wantShoot && player.shootCd <= 0) {
      player.shootCd = shootDelay;
      bullets.push({ x: player.x, y: player.y - 22, vy: -720, r: 5 });
      addParticleBurst(player.x, player.y - 28, 6);
      sfx.shoot();
    }

    // spawn enemies
    spawnTimer -= dt;
    if (spawnTimer <= 0) {
      spawnTimer = spawnRate;
      spawnEnemy();
    }

    // bullets
    bullets.forEach(b => b.y += b.vy * dt);
    bullets = bullets.filter(b => b.y > -30);

    // enemies
    enemies.forEach(e => {
      e.x += e.vx * dt;
      e.y += e.vy * dt;
      e.ang += e.spin * dt;
      if (e.x < 18 || e.x > W - 18) e.vx *= -1;
    });
    enemies = enemies.filter(e => e.y < H + 60);

    // particles
    for (const p of particles) {
      p.life -= dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 420 * dt;
      p.a = clamp(p.life / 0.65, 0, 1);
    }
    particles = particles.filter(p => p.life > 0);

    // bullet vs enemy
    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      for (let j = bullets.length - 1; j >= 0; j--) {
        const b = bullets[j];
        if (hitCircle(e.x, e.y, e.r, b.x, b.y, b.r)) {
          bullets.splice(j, 1);
          e.hp -= 1;
          addParticleBurst(b.x, b.y, 10);
          sfx.hit();
          if (e.hp <= 0) {
            enemies.splice(i, 1);
            score += (e.kind === "bossy") ? 60 : 20;
            scoreEl.textContent = score;
            addParticleBurst(e.x, e.y, e.kind === "bossy" ? 30 : 18);
            sfx.boom();
            if (score > wave * 250) wave += 1;
          }
          break;
        }
      }
    }

    // player vs enemy
    player.inv -= dt;
    if (player.inv < 0) player.inv = 0;

    if (player.inv === 0) {
      for (const e of enemies) {
        if (hitCircle(player.x, player.y, player.r, e.x, e.y, e.r)) {
          life -= 1;
          lifeEl.textContent = life;
          player.inv = 1.2;
          addParticleBurst(player.x, player.y, 40);
          sfx.damage();
          e.hp = 0;
          if (life <= 0) {
            running = false;
            // game over sting
            sfx.boom();
          }
          break;
        }
      }
      enemies = enemies.filter(e => e.hp > 0);
    }
  }

  // ====== Draw ======
  function draw() {
    ctx.clearRect(0, 0, W, H);

    // stars
    ctx.save();
    for (const s of stars) {
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = "rgba(255,255,255,.85)";
      ctx.fillRect(s.x, s.y, s.s, s.s);
    }
    ctx.restore();

    // vignette
    ctx.save();
    ctx.globalAlpha = 0.35;
    const g = ctx.createRadialGradient(W/2, H/2, 80, W/2, H/2, 520);
    g.addColorStop(0, "rgba(0,0,0,0)");
    g.addColorStop(1, "rgba(0,0,0,0.75)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);
    ctx.restore();

    for (const b of bullets) drawBullet(b);
    for (const e of enemies) drawEnemy(e);

    const blink = player.inv > 0 ? (Math.floor(now()/90) % 2 === 0) : false;
    if (!blink) drawShip(player.x, player.y, player.r, player.inv > 0);

    for (const p of particles) {
      ctx.save();
      ctx.globalAlpha = p.a;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,255,255,.9)";
      ctx.fill();
      ctx.restore();
    }

    if (!running) {
      ctx.save();
      ctx.globalAlpha = 0.92;
      ctx.fillStyle = "rgba(0,0,0,.55)";
      ctx.fillRect(0, 0, W, H);

      ctx.textAlign = "center";
      ctx.fillStyle = "rgba(255,255,255,.95)";
      ctx.font = "800 40px system-ui";
      ctx.fillText("GAME OVER", W/2, H/2 - 20);

      ctx.font = "700 16px system-ui";
      ctx.fillStyle = "rgba(255,255,255,.85)";
      ctx.fillText(`Score: ${score}   Wave: ${wave}`, W/2, H/2 + 18);

      ctx.fillStyle = "rgba(255,255,255,.75)";
      ctx.fillText("Restart„ÅßÂÜçÊåëÊà¶", W/2, H/2 + 48);
      ctx.restore();
    }
  }

  // ====== Loop ======
  function loop() {
    const t = now();
    const dt = Math.min(0.033, (t - lastT) / 1000);
    lastT = t;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  reset();
  loop();
})();
</script>
</body>
</html>
